/* BaseDatos.c generated by valac 0.22.1, the Vala compiler
 * generated from BaseDatos.vala, do not modify */

/** Manipulacion de archivos */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <sqlite3.h>
#include <glib/gstdio.h>
#include <gee.h>
#include <float.h>
#include <math.h>


#define GRAPH_MEDIA_TYPE_BASE_DATOS (graph_media_base_datos_get_type ())
#define GRAPH_MEDIA_BASE_DATOS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRAPH_MEDIA_TYPE_BASE_DATOS, GraphMediaBaseDatos))
#define GRAPH_MEDIA_BASE_DATOS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRAPH_MEDIA_TYPE_BASE_DATOS, GraphMediaBaseDatosClass))
#define GRAPH_MEDIA_IS_BASE_DATOS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRAPH_MEDIA_TYPE_BASE_DATOS))
#define GRAPH_MEDIA_IS_BASE_DATOS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRAPH_MEDIA_TYPE_BASE_DATOS))
#define GRAPH_MEDIA_BASE_DATOS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRAPH_MEDIA_TYPE_BASE_DATOS, GraphMediaBaseDatosClass))

typedef struct _GraphMediaBaseDatos GraphMediaBaseDatos;
typedef struct _GraphMediaBaseDatosClass GraphMediaBaseDatosClass;
typedef struct _GraphMediaBaseDatosPrivate GraphMediaBaseDatosPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _sqlite3_close0(var) ((var == NULL) ? NULL : (var = (sqlite3_close (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define GRAPH_MEDIA_MODELOS_TYPE_ARCHIVO (graph_media_modelos_archivo_get_type ())
#define GRAPH_MEDIA_MODELOS_ARCHIVO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRAPH_MEDIA_MODELOS_TYPE_ARCHIVO, GraphMediaModelosArchivo))
#define GRAPH_MEDIA_MODELOS_ARCHIVO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRAPH_MEDIA_MODELOS_TYPE_ARCHIVO, GraphMediaModelosArchivoClass))
#define GRAPH_MEDIA_MODELOS_IS_ARCHIVO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRAPH_MEDIA_MODELOS_TYPE_ARCHIVO))
#define GRAPH_MEDIA_MODELOS_IS_ARCHIVO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRAPH_MEDIA_MODELOS_TYPE_ARCHIVO))
#define GRAPH_MEDIA_MODELOS_ARCHIVO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRAPH_MEDIA_MODELOS_TYPE_ARCHIVO, GraphMediaModelosArchivoClass))

typedef struct _GraphMediaModelosArchivo GraphMediaModelosArchivo;
typedef struct _GraphMediaModelosArchivoClass GraphMediaModelosArchivoClass;

#define GRAPH_MEDIA_MODELOS_TYPE_SENTIMIENTO (graph_media_modelos_sentimiento_get_type ())
#define GRAPH_MEDIA_MODELOS_SENTIMIENTO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRAPH_MEDIA_MODELOS_TYPE_SENTIMIENTO, GraphMediaModelosSentimiento))
#define GRAPH_MEDIA_MODELOS_SENTIMIENTO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRAPH_MEDIA_MODELOS_TYPE_SENTIMIENTO, GraphMediaModelosSentimientoClass))
#define GRAPH_MEDIA_MODELOS_IS_SENTIMIENTO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRAPH_MEDIA_MODELOS_TYPE_SENTIMIENTO))
#define GRAPH_MEDIA_MODELOS_IS_SENTIMIENTO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRAPH_MEDIA_MODELOS_TYPE_SENTIMIENTO))
#define GRAPH_MEDIA_MODELOS_SENTIMIENTO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRAPH_MEDIA_MODELOS_TYPE_SENTIMIENTO, GraphMediaModelosSentimientoClass))

typedef struct _GraphMediaModelosSentimiento GraphMediaModelosSentimiento;
typedef struct _GraphMediaModelosSentimientoClass GraphMediaModelosSentimientoClass;

#define GRAPH_MEDIA_MODELOS_TYPE_PERSONA (graph_media_modelos_persona_get_type ())
#define GRAPH_MEDIA_MODELOS_PERSONA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRAPH_MEDIA_MODELOS_TYPE_PERSONA, GraphMediaModelosPersona))
#define GRAPH_MEDIA_MODELOS_PERSONA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRAPH_MEDIA_MODELOS_TYPE_PERSONA, GraphMediaModelosPersonaClass))
#define GRAPH_MEDIA_MODELOS_IS_PERSONA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRAPH_MEDIA_MODELOS_TYPE_PERSONA))
#define GRAPH_MEDIA_MODELOS_IS_PERSONA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRAPH_MEDIA_MODELOS_TYPE_PERSONA))
#define GRAPH_MEDIA_MODELOS_PERSONA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRAPH_MEDIA_MODELOS_TYPE_PERSONA, GraphMediaModelosPersonaClass))

typedef struct _GraphMediaModelosPersona GraphMediaModelosPersona;
typedef struct _GraphMediaModelosPersonaClass GraphMediaModelosPersonaClass;

#define GRAPH_MEDIA_MODELOS_TYPE_CANCION (graph_media_modelos_cancion_get_type ())
#define GRAPH_MEDIA_MODELOS_CANCION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRAPH_MEDIA_MODELOS_TYPE_CANCION, GraphMediaModelosCancion))
#define GRAPH_MEDIA_MODELOS_CANCION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRAPH_MEDIA_MODELOS_TYPE_CANCION, GraphMediaModelosCancionClass))
#define GRAPH_MEDIA_MODELOS_IS_CANCION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRAPH_MEDIA_MODELOS_TYPE_CANCION))
#define GRAPH_MEDIA_MODELOS_IS_CANCION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRAPH_MEDIA_MODELOS_TYPE_CANCION))
#define GRAPH_MEDIA_MODELOS_CANCION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRAPH_MEDIA_MODELOS_TYPE_CANCION, GraphMediaModelosCancionClass))

typedef struct _GraphMediaModelosCancion GraphMediaModelosCancion;
typedef struct _GraphMediaModelosCancionClass GraphMediaModelosCancionClass;
typedef struct _Block1Data Block1Data;
#define _graph_media_modelos_archivo_unref0(var) ((var == NULL) ? NULL : (var = (graph_media_modelos_archivo_unref (var), NULL)))

#define GRAPH_MEDIA_MODELOS_TYPE_ALBUM (graph_media_modelos_album_get_type ())
#define GRAPH_MEDIA_MODELOS_ALBUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRAPH_MEDIA_MODELOS_TYPE_ALBUM, GraphMediaModelosAlbum))
#define GRAPH_MEDIA_MODELOS_ALBUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRAPH_MEDIA_MODELOS_TYPE_ALBUM, GraphMediaModelosAlbumClass))
#define GRAPH_MEDIA_MODELOS_IS_ALBUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRAPH_MEDIA_MODELOS_TYPE_ALBUM))
#define GRAPH_MEDIA_MODELOS_IS_ALBUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRAPH_MEDIA_MODELOS_TYPE_ALBUM))
#define GRAPH_MEDIA_MODELOS_ALBUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRAPH_MEDIA_MODELOS_TYPE_ALBUM, GraphMediaModelosAlbumClass))

typedef struct _GraphMediaModelosAlbum GraphMediaModelosAlbum;
typedef struct _GraphMediaModelosAlbumClass GraphMediaModelosAlbumClass;

#define GRAPH_MEDIA_MODELOS_TYPE_ALBUM_CANCIONES (graph_media_modelos_album_canciones_get_type ())
#define GRAPH_MEDIA_MODELOS_ALBUM_CANCIONES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRAPH_MEDIA_MODELOS_TYPE_ALBUM_CANCIONES, GraphMediaModelosAlbumCanciones))
#define GRAPH_MEDIA_MODELOS_ALBUM_CANCIONES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRAPH_MEDIA_MODELOS_TYPE_ALBUM_CANCIONES, GraphMediaModelosAlbumCancionesClass))
#define GRAPH_MEDIA_MODELOS_IS_ALBUM_CANCIONES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRAPH_MEDIA_MODELOS_TYPE_ALBUM_CANCIONES))
#define GRAPH_MEDIA_MODELOS_IS_ALBUM_CANCIONES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRAPH_MEDIA_MODELOS_TYPE_ALBUM_CANCIONES))
#define GRAPH_MEDIA_MODELOS_ALBUM_CANCIONES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRAPH_MEDIA_MODELOS_TYPE_ALBUM_CANCIONES, GraphMediaModelosAlbumCancionesClass))

typedef struct _GraphMediaModelosAlbumCanciones GraphMediaModelosAlbumCanciones;
typedef struct _GraphMediaModelosAlbumCancionesClass GraphMediaModelosAlbumCancionesClass;

#define GRAPH_MEDIA_MODELOS_TYPE_ARTISTA (graph_media_modelos_artista_get_type ())
#define GRAPH_MEDIA_MODELOS_ARTISTA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRAPH_MEDIA_MODELOS_TYPE_ARTISTA, GraphMediaModelosArtista))
#define GRAPH_MEDIA_MODELOS_ARTISTA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRAPH_MEDIA_MODELOS_TYPE_ARTISTA, GraphMediaModelosArtistaClass))
#define GRAPH_MEDIA_MODELOS_IS_ARTISTA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRAPH_MEDIA_MODELOS_TYPE_ARTISTA))
#define GRAPH_MEDIA_MODELOS_IS_ARTISTA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRAPH_MEDIA_MODELOS_TYPE_ARTISTA))
#define GRAPH_MEDIA_MODELOS_ARTISTA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRAPH_MEDIA_MODELOS_TYPE_ARTISTA, GraphMediaModelosArtistaClass))

typedef struct _GraphMediaModelosArtista GraphMediaModelosArtista;
typedef struct _GraphMediaModelosArtistaClass GraphMediaModelosArtistaClass;
typedef struct _Block2Data Block2Data;
#define _graph_media_modelos_persona_unref0(var) ((var == NULL) ? NULL : (var = (graph_media_modelos_persona_unref (var), NULL)))

#define GRAPH_MEDIA_MODELOS_TYPE_ALBUM_IMAGENES (graph_media_modelos_album_imagenes_get_type ())
#define GRAPH_MEDIA_MODELOS_ALBUM_IMAGENES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRAPH_MEDIA_MODELOS_TYPE_ALBUM_IMAGENES, GraphMediaModelosAlbumImagenes))
#define GRAPH_MEDIA_MODELOS_ALBUM_IMAGENES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRAPH_MEDIA_MODELOS_TYPE_ALBUM_IMAGENES, GraphMediaModelosAlbumImagenesClass))
#define GRAPH_MEDIA_MODELOS_IS_ALBUM_IMAGENES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRAPH_MEDIA_MODELOS_TYPE_ALBUM_IMAGENES))
#define GRAPH_MEDIA_MODELOS_IS_ALBUM_IMAGENES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRAPH_MEDIA_MODELOS_TYPE_ALBUM_IMAGENES))
#define GRAPH_MEDIA_MODELOS_ALBUM_IMAGENES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRAPH_MEDIA_MODELOS_TYPE_ALBUM_IMAGENES, GraphMediaModelosAlbumImagenesClass))

typedef struct _GraphMediaModelosAlbumImagenes GraphMediaModelosAlbumImagenes;
typedef struct _GraphMediaModelosAlbumImagenesClass GraphMediaModelosAlbumImagenesClass;

#define GRAPH_MEDIA_MODELOS_TYPE_IMAGEN (graph_media_modelos_imagen_get_type ())
#define GRAPH_MEDIA_MODELOS_IMAGEN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GRAPH_MEDIA_MODELOS_TYPE_IMAGEN, GraphMediaModelosImagen))
#define GRAPH_MEDIA_MODELOS_IMAGEN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GRAPH_MEDIA_MODELOS_TYPE_IMAGEN, GraphMediaModelosImagenClass))
#define GRAPH_MEDIA_MODELOS_IS_IMAGEN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GRAPH_MEDIA_MODELOS_TYPE_IMAGEN))
#define GRAPH_MEDIA_MODELOS_IS_IMAGEN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GRAPH_MEDIA_MODELOS_TYPE_IMAGEN))
#define GRAPH_MEDIA_MODELOS_IMAGEN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GRAPH_MEDIA_MODELOS_TYPE_IMAGEN, GraphMediaModelosImagenClass))

typedef struct _GraphMediaModelosImagen GraphMediaModelosImagen;
typedef struct _GraphMediaModelosImagenClass GraphMediaModelosImagenClass;

#define GRAPH_MEDIA_MODELOS_TYPE_EPOCA (graph_media_modelos_epoca_get_type ())
typedef struct _GraphMediaModelosEpoca GraphMediaModelosEpoca;

typedef enum  {
	GRAPH_MEDIA_ERROR_BASE_DATOS_ARCHIVO_NO_ENCONTRADO,
	GRAPH_MEDIA_ERROR_BASE_DATOS_ARCHIVO_INVALIDO,
	GRAPH_MEDIA_ERROR_BASE_DATOS_ERROR_CONSULTA
} GraphMediaErrorBaseDatos;
#define GRAPH_MEDIA_ERROR_BASE_DATOS graph_media_error_base_datos_quark ()
struct _GraphMediaBaseDatos {
	GObject parent_instance;
	GraphMediaBaseDatosPrivate * priv;
};

struct _GraphMediaBaseDatosClass {
	GObjectClass parent_class;
};

struct _GraphMediaBaseDatosPrivate {
	gchar* NOMBRE_BDD;
	sqlite3* bdd;
};

struct _Block1Data {
	int _ref_count_;
	GraphMediaBaseDatos * self;
	GeeLinkedList* canciones;
};

struct _Block2Data {
	int _ref_count_;
	GraphMediaBaseDatos * self;
	GeeLinkedList* artistas;
};

struct _GraphMediaModelosEpoca {
	GDateTime* fecha;
};


static gpointer graph_media_base_datos_parent_class = NULL;

GQuark graph_media_error_base_datos_quark (void);
GType graph_media_base_datos_get_type (void) G_GNUC_CONST;
#define GRAPH_MEDIA_BASE_DATOS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GRAPH_MEDIA_TYPE_BASE_DATOS, GraphMediaBaseDatosPrivate))
enum  {
	GRAPH_MEDIA_BASE_DATOS_DUMMY_PROPERTY
};
GraphMediaBaseDatos* graph_media_base_datos_new (const gchar* nombre_archivo, GError** error);
GraphMediaBaseDatos* graph_media_base_datos_construct (GType object_type, const gchar* nombre_archivo, GError** error);
gpointer graph_media_modelos_archivo_ref (gpointer instance);
void graph_media_modelos_archivo_unref (gpointer instance);
GParamSpec* graph_media_modelos_param_spec_archivo (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void graph_media_modelos_value_set_archivo (GValue* value, gpointer v_object);
void graph_media_modelos_value_take_archivo (GValue* value, gpointer v_object);
gpointer graph_media_modelos_value_get_archivo (const GValue* value);
GType graph_media_modelos_archivo_get_type (void) G_GNUC_CONST;
void graph_media_base_datos_insertar_archivo (GraphMediaBaseDatos* self, GraphMediaModelosArchivo* a);
gboolean graph_media_modelos_archivo_get_disponible (GraphMediaModelosArchivo* self);
const gchar* graph_media_modelos_archivo_get_nombre (GraphMediaModelosArchivo* self);
const gchar* graph_media_modelos_archivo_get_ubicacion (GraphMediaModelosArchivo* self);
const gchar* graph_media_modelos_archivo_get_tipo (GraphMediaModelosArchivo* self);
const gchar* graph_media_modelos_archivo_get_u_acceso (GraphMediaModelosArchivo* self);
static gboolean graph_media_base_datos_existe_archivo (GraphMediaBaseDatos* self, GraphMediaModelosArchivo* a);
static void graph_media_base_datos_eliminar_archivo (GraphMediaBaseDatos* self, GraphMediaModelosArchivo* a);
gpointer graph_media_modelos_sentimiento_ref (gpointer instance);
void graph_media_modelos_sentimiento_unref (gpointer instance);
GParamSpec* graph_media_modelos_param_spec_sentimiento (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void graph_media_modelos_value_set_sentimiento (GValue* value, gpointer v_object);
void graph_media_modelos_value_take_sentimiento (GValue* value, gpointer v_object);
gpointer graph_media_modelos_value_get_sentimiento (const GValue* value);
GType graph_media_modelos_sentimiento_get_type (void) G_GNUC_CONST;
void graph_media_base_datos_vincular_archivo_sentimiento (GraphMediaBaseDatos* self, GraphMediaModelosArchivo* a, GraphMediaModelosSentimiento* s);
gpointer graph_media_modelos_persona_ref (gpointer instance);
void graph_media_modelos_persona_unref (gpointer instance);
GParamSpec* graph_media_modelos_param_spec_persona (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void graph_media_modelos_value_set_persona (GValue* value, gpointer v_object);
void graph_media_modelos_value_take_persona (GValue* value, gpointer v_object);
gpointer graph_media_modelos_value_get_persona (const GValue* value);
GType graph_media_modelos_persona_get_type (void) G_GNUC_CONST;
void graph_media_base_datos_vincular_archivo_persona (GraphMediaBaseDatos* self, GraphMediaModelosPersona* p, GraphMediaModelosArchivo* a);
GType graph_media_modelos_cancion_get_type (void) G_GNUC_CONST;
GeeLinkedList* graph_media_base_datos_listar_canciones (GraphMediaBaseDatos* self, const gchar* filtro, gint limite);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gchar* graph_media_base_datos_sanitizar_sql (GraphMediaBaseDatos* self, const gchar* sql);
static gint __lambda3_ (Block1Data* _data1_, gint n, gchar** datos, int datos_length1, gchar** nombres, int nombres_length1);
GraphMediaModelosCancion* graph_media_modelos_cancion_new_desde_campo (gint id, const gchar* nombre, const gchar* ubicacion, const gchar* u_acceso, gdouble popularidad, gboolean disponible);
GraphMediaModelosCancion* graph_media_modelos_cancion_construct_desde_campo (GType object_type, gint id, const gchar* nombre, const gchar* ubicacion, const gchar* u_acceso, gdouble popularidad, gboolean disponible);
static gint ___lambda3__sqlite3_callback (gpointer self, gint n_columns, gchar** values, gchar** column_names);
void graph_media_base_datos_eliminar_cancion (GraphMediaBaseDatos* self, GraphMediaModelosCancion* a);
gpointer graph_media_modelos_album_ref (gpointer instance);
void graph_media_modelos_album_unref (gpointer instance);
GParamSpec* graph_media_modelos_param_spec_album (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void graph_media_modelos_value_set_album (GValue* value, gpointer v_object);
void graph_media_modelos_value_take_album (GValue* value, gpointer v_object);
gpointer graph_media_modelos_value_get_album (const GValue* value);
GType graph_media_modelos_album_get_type (void) G_GNUC_CONST;
GType graph_media_modelos_album_canciones_get_type (void) G_GNUC_CONST;
void graph_media_base_datos_vincular_cancion_album (GraphMediaBaseDatos* self, GraphMediaModelosCancion* a, GraphMediaModelosAlbumCanciones* ac);
void graph_media_base_datos_registrar_persona (GraphMediaBaseDatos* self, GraphMediaModelosPersona* p);
void graph_media_base_datos_eliminar_persona (GraphMediaBaseDatos* self, GraphMediaModelosPersona* p);
void graph_media_base_datos_vincular_persona_sentimiento (GraphMediaBaseDatos* self, GraphMediaModelosPersona* e, GraphMediaModelosSentimiento* s);
GeeLinkedList* graph_media_base_datos_listar_personas (GraphMediaBaseDatos* self, const gchar* filtro, gint limite);
GType graph_media_modelos_artista_get_type (void) G_GNUC_CONST;
void graph_media_base_datos_vincular_artista_album (GraphMediaBaseDatos* self, GraphMediaModelosArtista* a, GraphMediaModelosAlbumCanciones* al);
GeeLinkedList* graph_media_base_datos_listar_artistas (GraphMediaBaseDatos* self, const gchar* filtro);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static gint __lambda4_ (Block2Data* _data2_, gint n, gchar** d, int d_length1, gchar** nombres, int nombres_length1);
GraphMediaModelosArtista* graph_media_modelos_artista_new (gint id, const gchar* nombre, gint edad, gdouble popularidad, const gchar* nacionalidad, const gchar* imagen);
GraphMediaModelosArtista* graph_media_modelos_artista_construct (GType object_type, gint id, const gchar* nombre, gint edad, gdouble popularidad, const gchar* nacionalidad, const gchar* imagen);
static gint ___lambda4__sqlite3_callback (gpointer self, gint n_columns, gchar** values, gchar** column_names);
void graph_media_base_datos_registrar_album_musical (GraphMediaBaseDatos* self, GraphMediaModelosAlbumCanciones* album);
void graph_media_base_datos_eliminar_album_musical (GraphMediaBaseDatos* self, GraphMediaModelosAlbumCanciones* album);
void graph_media_base_datos_registrar_album_imagenes (GraphMediaBaseDatos* self, GraphMediaModelosAlbumCanciones* album);
GType graph_media_modelos_album_imagenes_get_type (void) G_GNUC_CONST;
void graph_media_base_datos_eliminar_album_imagenes (GraphMediaBaseDatos* self, GraphMediaModelosAlbumImagenes* ai);
GType graph_media_modelos_imagen_get_type (void) G_GNUC_CONST;
void graph_media_base_datos_vincular_imagen_album (GraphMediaBaseDatos* self, GraphMediaModelosImagen* i, GraphMediaModelosAlbumImagenes* ai);
GType graph_media_modelos_epoca_get_type (void) G_GNUC_CONST;
GraphMediaModelosEpoca* graph_media_modelos_epoca_dup (const GraphMediaModelosEpoca* self);
void graph_media_modelos_epoca_free (GraphMediaModelosEpoca* self);
void graph_media_modelos_epoca_copy (const GraphMediaModelosEpoca* self, GraphMediaModelosEpoca* dest);
void graph_media_modelos_epoca_destroy (GraphMediaModelosEpoca* self);
void graph_media_base_datos_vincular_album_epoca (GraphMediaBaseDatos* self, GraphMediaModelosEpoca* e, GraphMediaModelosAlbum* a);
void graph_media_base_datos_registrar_epoca (GraphMediaBaseDatos* self, GraphMediaModelosEpoca* e);
void graph_media_base_datos_eliminar_epoca (GraphMediaBaseDatos* self, GraphMediaModelosEpoca* e);
void graph_media_base_datos_registrar_sentimiento (GraphMediaBaseDatos* self, GraphMediaModelosSentimiento* e);
void graph_media_base_datos_eliminar_sentimiento (GraphMediaBaseDatos* self, GraphMediaModelosSentimiento* s);
void graph_media_base_datos_eliminar_imagen (GraphMediaBaseDatos* self, GraphMediaModelosImagen* i);
static void graph_media_base_datos_finalize (GObject* obj);


GQuark graph_media_error_base_datos_quark (void) {
	return g_quark_from_static_string ("graph_media_error_base_datos-quark");
}


/**
* Constructor por defecto, recibe el nombre de un archivo 
* y crea una nueva BaseDatos con el 
*/
GraphMediaBaseDatos* graph_media_base_datos_construct (GType object_type, const gchar* nombre_archivo, GError** error) {
	GraphMediaBaseDatos * self = NULL;
	gint celdas = 0;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	const gchar* _tmp5_ = NULL;
	sqlite3* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (nombre_archivo != NULL, NULL);
	self = (GraphMediaBaseDatos*) g_object_new (object_type, NULL);
	celdas = 0;
	_tmp0_ = nombre_archivo;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->NOMBRE_BDD);
	self->priv->NOMBRE_BDD = _tmp1_;
	_tmp2_ = nombre_archivo;
	_tmp3_ = g_file_test (_tmp2_, G_FILE_TEST_IS_REGULAR);
	if (!_tmp3_) {
		GError* _tmp4_ = NULL;
		_tmp4_ = g_error_new_literal (GRAPH_MEDIA_ERROR_BASE_DATOS, GRAPH_MEDIA_ERROR_BASE_DATOS_ARCHIVO_NO_ENCONTRADO, "No se encontro el arhivo");
		_inner_error_ = _tmp4_;
		if (_inner_error_->domain == GRAPH_MEDIA_ERROR_BASE_DATOS) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp5_ = nombre_archivo;
	_tmp7_ = sqlite3_open (_tmp5_, &_tmp6_);
	_sqlite3_close0 (self->priv->bdd);
	self->priv->bdd = _tmp6_;
	celdas = _tmp7_;
	_tmp8_ = celdas;
	if (_tmp8_ != SQLITE_OK) {
		const gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		GError* _tmp14_ = NULL;
		GError* _tmp15_ = NULL;
		_tmp9_ = nombre_archivo;
		_tmp10_ = g_strconcat ("El archivo ", _tmp9_, NULL);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strconcat (_tmp11_, " no es válido", NULL);
		_tmp13_ = _tmp12_;
		_tmp14_ = g_error_new_literal (GRAPH_MEDIA_ERROR_BASE_DATOS, GRAPH_MEDIA_ERROR_BASE_DATOS_ARCHIVO_INVALIDO, _tmp13_);
		_tmp15_ = _tmp14_;
		_g_free0 (_tmp13_);
		_g_free0 (_tmp11_);
		_inner_error_ = _tmp15_;
		if (_inner_error_->domain == GRAPH_MEDIA_ERROR_BASE_DATOS) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	return self;
}


GraphMediaBaseDatos* graph_media_base_datos_new (const gchar* nombre_archivo, GError** error) {
	return graph_media_base_datos_construct (GRAPH_MEDIA_TYPE_BASE_DATOS, nombre_archivo, error);
}


/**
* Inserta un nuevo archivo dentro de la base de datos
*/
static gint _sqlite3_exec (sqlite3* self, const gchar* sql, sqlite3_callback callback, void* callback_target, gchar** errmsg) {
	gchar* _vala_errmsg = NULL;
	gint result = 0;
	const gchar* sqlite_errmsg = NULL;
	gint ec = 0;
	const gchar* _tmp0_ = NULL;
	sqlite3_callback _tmp1_ = NULL;
	void* _tmp1__target = NULL;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	const gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (sql != NULL, 0);
	_tmp0_ = sql;
	_tmp1_ = callback;
	_tmp1__target = callback_target;
	_tmp3_ = sqlite3_exec (self, _tmp0_, _tmp1_, _tmp1__target, (char**) (&_tmp2_));
	sqlite_errmsg = _tmp2_;
	ec = _tmp3_;
	if ((&_vala_errmsg) != NULL) {
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp4_ = sqlite_errmsg;
		_tmp5_ = g_strdup (_tmp4_);
		_g_free0 (_vala_errmsg);
		_vala_errmsg = _tmp5_;
	}
	_tmp6_ = sqlite_errmsg;
	sqlite3_free ((void*) _tmp6_);
	result = ec;
	if (errmsg) {
		*errmsg = _vala_errmsg;
	} else {
		_g_free0 (_vala_errmsg);
	}
	return result;
}


void graph_media_base_datos_insertar_archivo (GraphMediaBaseDatos* self, GraphMediaModelosArchivo* a) {
	gint _tmp0_ = 0;
	GraphMediaModelosArchivo* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gchar* sql = NULL;
	GraphMediaModelosArchivo* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	GraphMediaModelosArchivo* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	GraphMediaModelosArchivo* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	GraphMediaModelosArchivo* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	gint _tmp16_ = 0;
	gchar* _tmp17_ = NULL;
	GraphMediaModelosArchivo* _tmp18_ = NULL;
	gboolean _tmp19_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (a != NULL);
	_tmp1_ = a;
	_tmp2_ = graph_media_modelos_archivo_get_disponible (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_) {
		_tmp0_ = 1;
	} else {
		_tmp0_ = 0;
	}
	_tmp4_ = a;
	_tmp5_ = graph_media_modelos_archivo_get_nombre (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = a;
	_tmp8_ = graph_media_modelos_archivo_get_ubicacion (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = a;
	_tmp11_ = graph_media_modelos_archivo_get_tipo (_tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = a;
	_tmp14_ = graph_media_modelos_archivo_get_u_acceso (_tmp13_);
	_tmp15_ = _tmp14_;
	_tmp16_ = _tmp0_;
	_tmp17_ = g_strdup_printf ("INSERT INTO archivos (nombre, ubicacion, tipo, ultimoAcceso, disponibl" \
"e) VALUES ('%s','%s','%s','%s', %d)", _tmp6_, _tmp9_, _tmp12_, _tmp15_, _tmp16_);
	sql = _tmp17_;
	_tmp18_ = a;
	_tmp19_ = graph_media_base_datos_existe_archivo (self, _tmp18_);
	if (!_tmp19_) {
		sqlite3* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		_tmp20_ = self->priv->bdd;
		_tmp21_ = sql;
		_sqlite3_exec (_tmp20_, _tmp21_, NULL, NULL, NULL);
	}
	_g_free0 (sql);
}


/**
* Elimina un archivo de la base de datos y todas las relaciones con el 
*/
static void graph_media_base_datos_eliminar_archivo (GraphMediaBaseDatos* self, GraphMediaModelosArchivo* a) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (a != NULL);
}


/**
* Crea una relacion entre una archivo y un sentimiento
*/
void graph_media_base_datos_vincular_archivo_sentimiento (GraphMediaBaseDatos* self, GraphMediaModelosArchivo* a, GraphMediaModelosSentimiento* s) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (a != NULL);
	g_return_if_fail (s != NULL);
}


/**
* Vincula a una persona con un archivo
*/
void graph_media_base_datos_vincular_archivo_persona (GraphMediaBaseDatos* self, GraphMediaModelosPersona* p, GraphMediaModelosArchivo* a) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (p != NULL);
	g_return_if_fail (a != NULL);
}


static gboolean graph_media_base_datos_existe_archivo (GraphMediaBaseDatos* self, GraphMediaModelosArchivo* a) {
	gboolean result = FALSE;
	gchar* sql = NULL;
	GraphMediaModelosArchivo* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gint celdas = 0;
	sqlite3* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (a != NULL, FALSE);
	_tmp0_ = a;
	_tmp1_ = graph_media_modelos_archivo_get_ubicacion (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("SELECT ubicacion from archivos where ubicacion='%s'", _tmp2_);
	sql = _tmp3_;
	_tmp4_ = self->priv->bdd;
	_tmp5_ = _sqlite3_exec (_tmp4_, sql, NULL, NULL, NULL);
	celdas = _tmp5_;
	result = celdas > 0;
	_g_free0 (sql);
	return result;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		GraphMediaBaseDatos * self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->canciones);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gdouble double_parse (const gchar* str) {
	gdouble result = 0.0;
	const gchar* _tmp0_ = NULL;
	gdouble _tmp1_ = 0.0;
	g_return_val_if_fail (str != NULL, 0.0);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtod (_tmp0_, NULL);
	result = _tmp1_;
	return result;
}


static gint __lambda3_ (Block1Data* _data1_, gint n, gchar** datos, int datos_length1, gchar** nombres, int nombres_length1) {
	GraphMediaBaseDatos * self;
	gint result = 0;
	gboolean disponible = FALSE;
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	const gchar* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	GeeLinkedList* _tmp3_ = NULL;
	gchar** _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	const gchar* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gchar** _tmp7_ = NULL;
	gint _tmp7__length1 = 0;
	const gchar* _tmp8_ = NULL;
	gchar** _tmp9_ = NULL;
	gint _tmp9__length1 = 0;
	const gchar* _tmp10_ = NULL;
	gchar** _tmp11_ = NULL;
	gint _tmp11__length1 = 0;
	const gchar* _tmp12_ = NULL;
	gchar** _tmp13_ = NULL;
	gint _tmp13__length1 = 0;
	const gchar* _tmp14_ = NULL;
	gdouble _tmp15_ = 0.0;
	GraphMediaModelosCancion* _tmp16_ = NULL;
	GraphMediaModelosCancion* _tmp17_ = NULL;
	self = _data1_->self;
	_tmp0_ = datos;
	_tmp0__length1 = datos_length1;
	_tmp1_ = _tmp0_[5];
	_tmp2_ = atoi (_tmp1_);
	disponible = _tmp2_ == 0;
	_tmp3_ = _data1_->canciones;
	_tmp4_ = datos;
	_tmp4__length1 = datos_length1;
	_tmp5_ = _tmp4_[0];
	_tmp6_ = atoi (_tmp5_);
	_tmp7_ = datos;
	_tmp7__length1 = datos_length1;
	_tmp8_ = _tmp7_[1];
	_tmp9_ = datos;
	_tmp9__length1 = datos_length1;
	_tmp10_ = _tmp9_[2];
	_tmp11_ = datos;
	_tmp11__length1 = datos_length1;
	_tmp12_ = _tmp11_[3];
	_tmp13_ = datos;
	_tmp13__length1 = datos_length1;
	_tmp14_ = _tmp13_[4];
	_tmp15_ = double_parse (_tmp14_);
	_tmp16_ = graph_media_modelos_cancion_new_desde_campo (_tmp6_, _tmp8_, _tmp10_, _tmp12_, _tmp15_, disponible);
	_tmp17_ = _tmp16_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp3_, _tmp17_);
	_graph_media_modelos_archivo_unref0 (_tmp17_);
	result = 0;
	return result;
}


static gint ___lambda3__sqlite3_callback (gpointer self, gint n_columns, gchar** values, gchar** column_names) {
	gint result;
	result = __lambda3_ (self, n_columns, values, -1, column_names, -1);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GeeLinkedList* graph_media_base_datos_listar_canciones (GraphMediaBaseDatos* self, const gchar* filtro, gint limite) {
	GeeLinkedList* result = NULL;
	Block1Data* _data1_;
	GeeLinkedList* _tmp0_ = NULL;
	gchar* filtro_filtrado = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* sql = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	sqlite3* _tmp8_ = NULL;
	GeeLinkedList* _tmp9_ = NULL;
	GeeLinkedList* _tmp10_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (filtro != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = gee_linked_list_new (GRAPH_MEDIA_MODELOS_TYPE_CANCION, (GBoxedCopyFunc) graph_media_modelos_archivo_ref, graph_media_modelos_archivo_unref, NULL, NULL, NULL);
	_data1_->canciones = _tmp0_;
	_tmp1_ = filtro;
	_tmp2_ = g_strdup (_tmp1_);
	filtro_filtrado = _tmp2_;
	_tmp3_ = filtro;
	if (g_strcmp0 (_tmp3_, "") != 0) {
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp4_ = filtro;
		_tmp5_ = graph_media_base_datos_sanitizar_sql (self, _tmp4_);
		_g_free0 (filtro_filtrado);
		filtro_filtrado = _tmp5_;
	}
	_tmp6_ = filtro_filtrado;
	_tmp7_ = g_strdup_printf ("SELECT id, nombre, ubicacion, ultimoAcceso, popularidad, disponible fr" \
"om archivos WHERE tipo='audio' AND nombre LIKE '%%s%' ORDER BY popular" \
"idad", _tmp6_);
	sql = _tmp7_;
	_tmp8_ = self->priv->bdd;
	_sqlite3_exec (_tmp8_, sql, ___lambda3__sqlite3_callback, _data1_, NULL);
	_tmp9_ = _data1_->canciones;
	_tmp10_ = _g_object_ref0 (_tmp9_);
	result = _tmp10_;
	_g_free0 (sql);
	_g_free0 (filtro_filtrado);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


/**
* Elimina una cancion y todas las relaciones con ella, 
* artistas, sentimientos;
*/
void graph_media_base_datos_eliminar_cancion (GraphMediaBaseDatos* self, GraphMediaModelosCancion* a) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (a != NULL);
}


/**
* Crea una relacion entre una cancion y un album de canciones
*/
void graph_media_base_datos_vincular_cancion_album (GraphMediaBaseDatos* self, GraphMediaModelosCancion* a, GraphMediaModelosAlbumCanciones* ac) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (a != NULL);
	g_return_if_fail (ac != NULL);
}


/**
* Agrega un nuevo artista o amigo  a la base de datos
*/
void graph_media_base_datos_registrar_persona (GraphMediaBaseDatos* self, GraphMediaModelosPersona* p) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (p != NULL);
}


/**
* Elimina un persona de la base de datos junto con todas sus 
* conexiones (fotos, canciones, sentimientos ...)
*/
void graph_media_base_datos_eliminar_persona (GraphMediaBaseDatos* self, GraphMediaModelosPersona* p) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (p != NULL);
}


/**
* Asocia a una persona con un sentimiento
*/
void graph_media_base_datos_vincular_persona_sentimiento (GraphMediaBaseDatos* self, GraphMediaModelosPersona* e, GraphMediaModelosSentimiento* s) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (e != NULL);
	g_return_if_fail (s != NULL);
}


/**
* Devuelve una lista de todas las personas contenidas dentro de la base de datos
* y las filtra de acuerdo al criterio que recibe 
*/
GeeLinkedList* graph_media_base_datos_listar_personas (GraphMediaBaseDatos* self, const gchar* filtro, gint limite) {
	GeeLinkedList* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (filtro != NULL, NULL);
	result = NULL;
	return result;
}


/**
* crea una nueva relacion entre un album y un artista
 */
void graph_media_base_datos_vincular_artista_album (GraphMediaBaseDatos* self, GraphMediaModelosArtista* a, GraphMediaModelosAlbumCanciones* al) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (a != NULL);
	g_return_if_fail (al != NULL);
}


/**
* Genera una lista de artistas de todos los artistas dentro de la tabla personas con 
* el valor 'Artista' en el campo rol
*/
static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		GraphMediaBaseDatos * self;
		self = _data2_->self;
		_g_object_unref0 (_data2_->artistas);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static gint __lambda4_ (Block2Data* _data2_, gint n, gchar** d, int d_length1, gchar** nombres, int nombres_length1) {
	GraphMediaBaseDatos * self;
	gint result = 0;
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	const gchar* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	const gchar* _tmp4_ = NULL;
	gchar** _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	const gchar* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gchar** _tmp8_ = NULL;
	gint _tmp8__length1 = 0;
	const gchar* _tmp9_ = NULL;
	gdouble _tmp10_ = 0.0;
	gchar** _tmp11_ = NULL;
	gint _tmp11__length1 = 0;
	const gchar* _tmp12_ = NULL;
	gchar** _tmp13_ = NULL;
	gint _tmp13__length1 = 0;
	const gchar* _tmp14_ = NULL;
	GraphMediaModelosArtista* _tmp15_ = NULL;
	GraphMediaModelosArtista* _tmp16_ = NULL;
	self = _data2_->self;
	_tmp0_ = d;
	_tmp0__length1 = d_length1;
	_tmp1_ = _tmp0_[0];
	_tmp2_ = atoi (_tmp1_);
	_tmp3_ = d;
	_tmp3__length1 = d_length1;
	_tmp4_ = _tmp3_[1];
	_tmp5_ = d;
	_tmp5__length1 = d_length1;
	_tmp6_ = _tmp5_[1];
	_tmp7_ = atoi (_tmp6_);
	_tmp8_ = d;
	_tmp8__length1 = d_length1;
	_tmp9_ = _tmp8_[2];
	_tmp10_ = double_parse (_tmp9_);
	_tmp11_ = d;
	_tmp11__length1 = d_length1;
	_tmp12_ = _tmp11_[3];
	_tmp13_ = d;
	_tmp13__length1 = d_length1;
	_tmp14_ = _tmp13_[4];
	_tmp15_ = graph_media_modelos_artista_new (_tmp2_, _tmp4_, _tmp7_, _tmp10_, _tmp12_, _tmp14_);
	_tmp16_ = _tmp15_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _data2_->artistas, _tmp16_);
	_graph_media_modelos_persona_unref0 (_tmp16_);
	result = 0;
	return result;
}


static gint ___lambda4__sqlite3_callback (gpointer self, gint n_columns, gchar** values, gchar** column_names) {
	gint result;
	result = __lambda4_ (self, n_columns, values, -1, column_names, -1);
	return result;
}


GeeLinkedList* graph_media_base_datos_listar_artistas (GraphMediaBaseDatos* self, const gchar* filtro) {
	GeeLinkedList* result = NULL;
	Block2Data* _data2_;
	GeeLinkedList* _tmp0_ = NULL;
	gchar* sql = NULL;
	gchar* _tmp1_ = NULL;
	sqlite3* _tmp2_ = NULL;
	GeeLinkedList* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (filtro != NULL, NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = g_object_ref (self);
	_tmp0_ = gee_linked_list_new (GRAPH_MEDIA_MODELOS_TYPE_ARTISTA, (GBoxedCopyFunc) graph_media_modelos_persona_ref, graph_media_modelos_persona_unref, NULL, NULL, NULL);
	_data2_->artistas = _tmp0_;
	_tmp1_ = g_strdup ("SELECT nombre, edad, popularidad, nacionalidad, imagen FROM personas W" \
"HERE rol='artista' ORDER by popularidad DESC");
	sql = _tmp1_;
	_tmp2_ = self->priv->bdd;
	_sqlite3_exec (_tmp2_, sql, ___lambda4__sqlite3_callback, _data2_, NULL);
	_tmp3_ = _g_object_ref0 (_data2_->artistas);
	result = _tmp3_;
	_g_free0 (sql);
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return result;
}


/**
* agrega un nuevo album musical la base de datos 
*/
void graph_media_base_datos_registrar_album_musical (GraphMediaBaseDatos* self, GraphMediaModelosAlbumCanciones* album) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (album != NULL);
}


/**
* agrega un nuevo album musical la base de datos 
*/
void graph_media_base_datos_eliminar_album_musical (GraphMediaBaseDatos* self, GraphMediaModelosAlbumCanciones* album) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (album != NULL);
}


/**
* agrega un nuevo album musical la base de datos 
*/
void graph_media_base_datos_registrar_album_imagenes (GraphMediaBaseDatos* self, GraphMediaModelosAlbumCanciones* album) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (album != NULL);
}


/**
 *	elimina un album de la base de datos al igual que todas 
 * sus relaciones 
 */
void graph_media_base_datos_eliminar_album_imagenes (GraphMediaBaseDatos* self, GraphMediaModelosAlbumImagenes* ai) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (ai != NULL);
}


/**
* Crea una nueva relacion entre determinado album y una imagen
*/
void graph_media_base_datos_vincular_imagen_album (GraphMediaBaseDatos* self, GraphMediaModelosImagen* i, GraphMediaModelosAlbumImagenes* ai) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (i != NULL);
	g_return_if_fail (ai != NULL);
}


/**
* Crea un vinculo entre un album y una epoca, sin importar si es 
* fotografico o de canciones
*/
void graph_media_base_datos_vincular_album_epoca (GraphMediaBaseDatos* self, GraphMediaModelosEpoca* e, GraphMediaModelosAlbum* a) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (e != NULL);
	g_return_if_fail (a != NULL);
}


/**
* agrega un nuevo regsitro de fechas a la tabla de epocas
*/
void graph_media_base_datos_registrar_epoca (GraphMediaBaseDatos* self, GraphMediaModelosEpoca* e) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (e != NULL);
}


/**
* elimina una epoca de los registros y todas sus relaciones con ello
*/
void graph_media_base_datos_eliminar_epoca (GraphMediaBaseDatos* self, GraphMediaModelosEpoca* e) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (e != NULL);
}


/**
* Agrega un nuevo sentimiento a la base de datos 
*/
void graph_media_base_datos_registrar_sentimiento (GraphMediaBaseDatos* self, GraphMediaModelosSentimiento* e) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (e != NULL);
}


/**
* Elimina un sentimiento y todas las relaciones con el
*/
void graph_media_base_datos_eliminar_sentimiento (GraphMediaBaseDatos* self, GraphMediaModelosSentimiento* s) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (s != NULL);
}


/**
* Elimina una imagen y todas sus relaciones con ella.
*/
void graph_media_base_datos_eliminar_imagen (GraphMediaBaseDatos* self, GraphMediaModelosImagen* i) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (i != NULL);
}


static gchar* graph_media_base_datos_sanitizar_sql (GraphMediaBaseDatos* self, const gchar* sql) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (sql != NULL, NULL);
	_tmp0_ = sql;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


static void graph_media_base_datos_class_init (GraphMediaBaseDatosClass * klass) {
	graph_media_base_datos_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GraphMediaBaseDatosPrivate));
	G_OBJECT_CLASS (klass)->finalize = graph_media_base_datos_finalize;
}


static void graph_media_base_datos_instance_init (GraphMediaBaseDatos * self) {
	self->priv = GRAPH_MEDIA_BASE_DATOS_GET_PRIVATE (self);
}


static void graph_media_base_datos_finalize (GObject* obj) {
	GraphMediaBaseDatos * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GRAPH_MEDIA_TYPE_BASE_DATOS, GraphMediaBaseDatos);
	_g_free0 (self->priv->NOMBRE_BDD);
	_sqlite3_close0 (self->priv->bdd);
	G_OBJECT_CLASS (graph_media_base_datos_parent_class)->finalize (obj);
}


/**
* Clase encargada  de manejar la conexion entre la base de datos
* y los modelos del sistema, realiza las consultas, y actualiza los objetos 
* y registros.
*/
GType graph_media_base_datos_get_type (void) {
	static volatile gsize graph_media_base_datos_type_id__volatile = 0;
	if (g_once_init_enter (&graph_media_base_datos_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GraphMediaBaseDatosClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) graph_media_base_datos_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GraphMediaBaseDatos), 0, (GInstanceInitFunc) graph_media_base_datos_instance_init, NULL };
		GType graph_media_base_datos_type_id;
		graph_media_base_datos_type_id = g_type_register_static (G_TYPE_OBJECT, "GraphMediaBaseDatos", &g_define_type_info, 0);
		g_once_init_leave (&graph_media_base_datos_type_id__volatile, graph_media_base_datos_type_id);
	}
	return graph_media_base_datos_type_id__volatile;
}



